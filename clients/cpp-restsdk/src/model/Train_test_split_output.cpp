/**
 * rest-cpp-data-science
 * data science REST API endpoints, parameters, and responses, including information about preprocessing data, training models, making predictions, and evaluating models.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.3.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/Train_test_split_output.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {



Train_test_split_output::Train_test_split_output()
{
    m_X_trainIsSet = false;
    m_X_testIsSet = false;
    m_Y_trainIsSet = false;
    m_Y_testIsSet = false;
}

Train_test_split_output::~Train_test_split_output()
{
}

void Train_test_split_output::validate()
{
    // TODO: implement validation
}

web::json::value Train_test_split_output::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_X_trainIsSet)
    {
        val[utility::conversions::to_string_t(U("x_train"))] = ModelBase::toJson(m_X_train);
    }
    if(m_X_testIsSet)
    {
        val[utility::conversions::to_string_t(U("x_test"))] = ModelBase::toJson(m_X_test);
    }
    if(m_Y_trainIsSet)
    {
        val[utility::conversions::to_string_t(U("y_train"))] = ModelBase::toJson(m_Y_train);
    }
    if(m_Y_testIsSet)
    {
        val[utility::conversions::to_string_t(U("y_test"))] = ModelBase::toJson(m_Y_test);
    }

    return val;
}

bool Train_test_split_output::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("x_train"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("x_train")));
        if(!fieldValue.is_null())
        {
            std::vector<std::vector<double>> refVal_setXTrain;
            ok &= ModelBase::fromJson(fieldValue, refVal_setXTrain);
            setXTrain(refVal_setXTrain);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("x_test"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("x_test")));
        if(!fieldValue.is_null())
        {
            std::vector<std::vector<double>> refVal_setXTest;
            ok &= ModelBase::fromJson(fieldValue, refVal_setXTest);
            setXTest(refVal_setXTest);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("y_train"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("y_train")));
        if(!fieldValue.is_null())
        {
            std::vector<double> refVal_setYTrain;
            ok &= ModelBase::fromJson(fieldValue, refVal_setYTrain);
            setYTrain(refVal_setYTrain);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("y_test"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("y_test")));
        if(!fieldValue.is_null())
        {
            std::vector<double> refVal_setYTest;
            ok &= ModelBase::fromJson(fieldValue, refVal_setYTest);
            setYTest(refVal_setYTest);
        }
    }
    return ok;
}

void Train_test_split_output::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_X_trainIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("x_train")), m_X_train));
    }
    if(m_X_testIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("x_test")), m_X_test));
    }
    if(m_Y_trainIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("y_train")), m_Y_train));
    }
    if(m_Y_testIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("y_test")), m_Y_test));
    }
}

bool Train_test_split_output::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("x_train"))))
    {
        std::vector<std::vector<double>> refVal_setXTrain;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("x_train"))), refVal_setXTrain );
        setXTrain(refVal_setXTrain);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("x_test"))))
    {
        std::vector<std::vector<double>> refVal_setXTest;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("x_test"))), refVal_setXTest );
        setXTest(refVal_setXTest);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("y_train"))))
    {
        std::vector<double> refVal_setYTrain;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("y_train"))), refVal_setYTrain );
        setYTrain(refVal_setYTrain);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("y_test"))))
    {
        std::vector<double> refVal_setYTest;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("y_test"))), refVal_setYTest );
        setYTest(refVal_setYTest);
    }
    return ok;
}

std::vector<std::vector<double>>& Train_test_split_output::getXTrain()
{
    return m_X_train;
}

void Train_test_split_output::setXTrain(const std::vector<std::vector<double>>& value)
{
    m_X_train = value;
    m_X_trainIsSet = true;
}

bool Train_test_split_output::xTrainIsSet() const
{
    return m_X_trainIsSet;
}

void Train_test_split_output::unsetX_train()
{
    m_X_trainIsSet = false;
}
std::vector<std::vector<double>>& Train_test_split_output::getXTest()
{
    return m_X_test;
}

void Train_test_split_output::setXTest(const std::vector<std::vector<double>>& value)
{
    m_X_test = value;
    m_X_testIsSet = true;
}

bool Train_test_split_output::xTestIsSet() const
{
    return m_X_testIsSet;
}

void Train_test_split_output::unsetX_test()
{
    m_X_testIsSet = false;
}
std::vector<double>& Train_test_split_output::getYTrain()
{
    return m_Y_train;
}

void Train_test_split_output::setYTrain(std::vector<double> value)
{
    m_Y_train = value;
    m_Y_trainIsSet = true;
}

bool Train_test_split_output::yTrainIsSet() const
{
    return m_Y_trainIsSet;
}

void Train_test_split_output::unsetY_train()
{
    m_Y_trainIsSet = false;
}
std::vector<double>& Train_test_split_output::getYTest()
{
    return m_Y_test;
}

void Train_test_split_output::setYTest(std::vector<double> value)
{
    m_Y_test = value;
    m_Y_testIsSet = true;
}

bool Train_test_split_output::yTestIsSet() const
{
    return m_Y_testIsSet;
}

void Train_test_split_output::unsetY_test()
{
    m_Y_testIsSet = false;
}
}
}
}
}


